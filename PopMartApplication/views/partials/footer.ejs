  </div>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <% if (typeof script === "string" && script.length) { %>
    <script src="<%= script %>"></script>
  <% } %>
  <script>
    (function () {
      const walletBtn = document.getElementById("connectWalletBtn");
      const walletLabel = document.getElementById("walletAddress");
      const disconnectBtn = document.getElementById("disconnectWalletBtn");
      const sellerVerifyForm = document.getElementById("sellerVerifyForm");
      const sellerVerificationStatus = document.getElementById("sellerVerificationStatus");
      const sellerVerifiedBadge = document.getElementById("sellerVerifiedBadge");
      const sellerLockedNotice = document.getElementById("sellerLockedNotice");
      const sellerLockTargets = document.querySelectorAll("[data-requires-seller-verified]");
      const sellerWalletField = document.getElementById("sellerWalletField");
      const checkoutForm = document.getElementById("checkoutForm");
      const buyerVerificationHint = document.getElementById("buyerVerificationHint");
      const state = {
        provider: null,
        signer: null,
        account: null,
        contract: null,
        verification: { seller: false, buyer: false },
      };
      const GAS_LIMIT = 600000;

      function getRoleLabel(address) {
        if (!address) return "";
        const account = address.toLowerCase();
        const sellerForms = Array.from(
          document.querySelectorAll('form[data-escrow-action="ship"]')
        );
        const buyerForms = Array.from(
          document.querySelectorAll(
            'form[data-escrow-action="deliver"], form[data-escrow-action="rate"]'
          )
        );
        const sellerWallets = new Set(
          sellerForms
            .map(function (form) {
              return (form.dataset.expectedWallet || "").toLowerCase();
            })
            .filter(Boolean)
        );
        const buyerWallets = new Set(
          buyerForms
            .map(function (form) {
              return (form.dataset.expectedWallet || "").toLowerCase();
            })
            .filter(Boolean)
        );
        const isSeller = sellerWallets.has(account);
        const isBuyer = buyerWallets.has(account);
        if (isSeller && isBuyer) return "Buyer/Seller";
        if (isSeller) return "Seller";
        if (isBuyer) return "Buyer";
        return "";
      }

      function setWalletUI(address) {
        if (walletLabel) {
          const role = address ? getRoleLabel(address) : "";
          if (!address) {
            walletLabel.textContent = "";
          } else if (role) {
            walletLabel.textContent = role + ": " + address;
          } else {
            walletLabel.textContent = address;
          }
        }
        if (walletBtn) {
          walletBtn.textContent = address ? "Wallet connected" : "Connect wallet";
        }
        if (sellerWalletField) {
          sellerWalletField.value = address || "";
        }
      }

      function setSellerLockUI(verified) {
        sellerLockTargets.forEach(function (el) {
          el.style.display = verified ? "" : "none";
        });
        if (sellerLockedNotice) {
          sellerLockedNotice.style.display = verified ? "none" : "block";
        }
        if (sellerVerifiedBadge) {
          sellerVerifiedBadge.style.display = verified ? "inline-flex" : "none";
        }
      }

      function setBuyerVerificationHint(verified) {
        if (!buyerVerificationHint) return;
        buyerVerificationHint.textContent = verified
          ? "Buyer details verified on-chain."
          : "Add phone + email and sign with MetaMask before checkout.";
      }

      function getProvider() {
        if (!window.ethereum) return null;
        if (Array.isArray(window.ethereum.providers)) {
          return window.ethereum.providers.find((p) => p.isMetaMask) || window.ethereum.providers[0];
        }
        return window.ethereum;
      }

      async function loadArtifact(path) {
        const res = await fetch(path, { cache: "no-store" });
        if (!res.ok) {
          throw new Error("Missing contract artifact: " + path);
        }
        return res.json();
      }

      async function resolveAddress(artifact, provider) {
        const networks = artifact.networks || {};
        const network = await provider.getNetwork();
        const chainId = String(network.chainId);
        const networkId = await provider.send("net_version", []).catch(function () {
          return null;
        });
        const direct = networks[chainId];
        if (direct && direct.address) {
          return { address: direct.address, chainId, networkId, usedNetworkKey: chainId };
        }
        if (networkId && networks[networkId] && networks[networkId].address) {
          return {
            address: networks[networkId].address,
            chainId,
            networkId,
            usedNetworkKey: String(networkId),
          };
        }
        const keys = Object.keys(networks);
        if (keys.length === 1 && networks[keys[0]].address) {
          return {
            address: networks[keys[0]].address,
            chainId,
            networkId,
            usedNetworkKey: String(keys[0]),
          };
        }
        return { address: null, chainId, networkId, usedNetworkKey: null };
      }

      async function findDeployedAddress(artifact, provider) {
        const networks = artifact.networks || {};
        const entries = Object.entries(networks);
        for (const entry of entries) {
          const key = entry[0];
          const info = entry[1];
          if (!info || !info.address) continue;
          const code = await provider.getCode(info.address);
          if (code && code !== "0x") {
            return { address: info.address, usedNetworkKey: String(key) };
          }
        }
        return null;
      }

      async function initContract() {
        if (!window.ethers) {
          throw new Error("Ethers library not loaded.");
        }
        const provider = getProvider();
        if (!provider) {
          throw new Error("MetaMask not detected.");
        }
        if (!state.provider) {
          state.provider = new window.ethers.providers.Web3Provider(provider);
          state.signer = state.provider.getSigner();
        }
        const artifact = await loadArtifact("/build/EscrowPayment.json");
        const deployment = await resolveAddress(artifact, state.provider);
        if (!deployment.address) {
          const suffix = deployment.networkId ? ` (network id ${deployment.networkId})` : "";
          throw new Error(`Escrow contract not deployed for chain ${deployment.chainId}${suffix}.`);
        }
        const code = await state.provider.getCode(deployment.address);
        if (!code || code === "0x") {
          const discovered = await findDeployedAddress(artifact, state.provider);
          if (discovered) {
            deployment.address = discovered.address;
            deployment.usedNetworkKey = discovered.usedNetworkKey;
          } else {
          const suffix = deployment.networkId ? `, network id ${deployment.networkId}` : "";
          const usedKey = deployment.usedNetworkKey
            ? ` from artifact network ${deployment.usedNetworkKey}`
            : "";
          throw new Error(
            `Escrow contract not found at ${deployment.address}. You are on chain ${deployment.chainId}${suffix}${usedKey}. Check MetaMask RPC (Ganache 127.0.0.1:7545) or re-deploy.`
          );
          }
        }
        state.contract = new window.ethers.Contract(
          deployment.address,
          artifact.abi,
          state.signer
        );
      }

      async function connectWallet() {
        const provider = getProvider();
        if (!provider) {
          throw new Error("MetaMask not detected.");
        }
        try {
          await provider.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: "0x539" }],
          });
        } catch (err) {
          if (err && err.code === 4902) {
            await provider.request({
              method: "wallet_addEthereumChain",
              params: [
                {
                  chainId: "0x539",
                  chainName: "Ganache 1337",
                  rpcUrls: ["http://127.0.0.1:7545"],
                  nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
                },
              ],
            });
          } else if (err && err.code !== 4001) {
            throw err;
          }
        }
        const accounts = await provider.request({ method: "eth_requestAccounts" });
        state.account = accounts && accounts.length ? accounts[0] : null;
        setWalletUI(state.account);
        if (!state.contract) {
          await initContract();
        }
        await fetchVerificationStatus(state.account);
        await syncSellerWallet(state.account);
        return state.account;
      }

      async function restoreWalletSession() {
        const provider = getProvider();
        if (!provider || typeof provider.request !== "function") return;
        const accounts = await provider.request({ method: "eth_accounts" });
        const account = accounts && accounts.length ? accounts[0] : "";
        state.account = account || null;
        setWalletUI(account);
        if (account) {
          if (!state.contract) {
            await initContract();
          }
          await fetchVerificationStatus(account);
          await syncSellerWallet(account);
        } else {
          state.verification = { seller: false, buyer: false };
          setSellerLockUI(false);
          setBuyerVerificationHint(false);
        }
      }

      async function ensureReady() {
        if (!state.account) {
          await connectWallet();
        }
        if (!state.contract) {
          await initContract();
        }
      }

      async function ensureExpectedAccount(expectedWallet) {
        if (!expectedWallet) return;
        const provider = getProvider();
        if (!provider) {
          throw new Error("MetaMask not detected.");
        }
        if (!state.account) {
          await connectWallet();
        }
        if (state.account && state.account.toLowerCase() !== expectedWallet) {
          const accounts = await provider.request({ method: "eth_requestAccounts" });
          state.account = accounts && accounts.length ? accounts[0] : null;
          setWalletUI(state.account);
        }
        if (!state.account || state.account.toLowerCase() !== expectedWallet) {
          throw new Error(
            "Switch MetaMask to " + expectedWallet + " before continuing."
          );
        }
        await syncSellerWallet(state.account);
      }

      async function fetchVerificationStatus(address) {
        if (!state.contract || !address) {
          state.verification = { seller: false, buyer: false };
          setSellerLockUI(false);
          setBuyerVerificationHint(false);
          return state.verification;
        }
        const info = await state.contract.getVerification(address);
        const sellerVerified = Boolean(info.sellerVerified);
        const buyerVerified = Boolean(info.buyerVerified);
        state.verification = { seller: sellerVerified, buyer: buyerVerified };
        setSellerLockUI(sellerVerified);
        setBuyerVerificationHint(buyerVerified);
        if (sellerVerificationStatus) {
          sellerVerificationStatus.textContent = sellerVerified
            ? "Seller verified for " + address
            : "Not verified yet.";
        }
        return state.verification;
      }

      async function syncSellerWallet(address) {
        if (!address) return;
        await fetch("/seller/wallet", {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: "sellerWallet=" + encodeURIComponent(address),
        });
      }

      function normalizeRpcError(err) {
        if (!err) return "";
        const message =
          (err.data && err.data.message) ||
          (err.error && err.error.message) ||
          err.reason ||
          err.message ||
          "";
        return message.replace("execution reverted: ", "").trim();
      }

      async function ensureSellerVerification(form) {
        if (!form) return state.verification;
        const name = form.querySelector("[name=sellerName]").value.trim();
        const email = form.querySelector("[name=sellerEmail]").value.trim();
        const phone = form.querySelector("[name=sellerPhone]").value.trim();
        if (!name || !email || !phone) {
          throw new Error("Provide name, email, and phone.");
        }
        if (sellerWalletField && sellerWalletField.value) {
          await ensureExpectedAccount(sellerWalletField.value.toLowerCase());
        } else {
          await ensureReady();
        }
        if (state.verification.seller) return state.verification;
        const tx = await state.contract.verifySeller(name, email, phone, { gasLimit: GAS_LIMIT });
        await tx.wait();
        return fetchVerificationStatus(state.account);
      }

      async function ensureBuyerVerification(info) {
        await ensureReady();
        const current = await fetchVerificationStatus(state.account);
        if (current.buyer) return current;
        const tx = await state.contract.verifyBuyer(info.name, info.email, info.phone, { gasLimit: GAS_LIMIT });
        await tx.wait();
        return fetchVerificationStatus(state.account);
      }

      async function getNextOrderId() {
        return state.contract.nextOrderId();
      }

      async function handleCheckout(form) {
        const cartEl = document.getElementById("cartData");
        const cart = cartEl ? JSON.parse(cartEl.textContent || "[]") : [];
        if (!cart.length) {
          throw new Error("Your cart is empty.");
        }
        const buyerName = form.querySelector("[name=buyerName]").value;
        const buyerEmail = form.querySelector("[name=buyerEmail]").value;
        const buyerPhone = form.querySelector("[name=buyerPhone]").value;
        const buyerAddress = form.querySelector("[name=buyerAddress]").value;
        const chainOrders = [];
        await ensureBuyerVerification({
          name: buyerName,
          email: buyerEmail,
          phone: buyerPhone,
        });

        for (const item of cart) {
          if (!item.sellerWallet || !window.ethers.utils.isAddress(item.sellerWallet)) {
            throw new Error(
              "Missing or invalid seller wallet for " + item.name + ". Ask the seller to reconnect."
            );
          }
          const qty = Number(item.qty || 0);
          const unitPriceWei = window.ethers.utils.parseEther(String(item.priceEth || 0));
          const totalWei = unitPriceWei.mul(window.ethers.BigNumber.from(qty));
          const expectedOrderId = await getNextOrderId();
          const tx = await state.contract.createOrder(
            item.productId,
            qty,
            unitPriceWei,
            { value: totalWei }
          );
          const receipt = await tx.wait();
          chainOrders.push({
            orderId: String(expectedOrderId),
            txHash: receipt.transactionHash,
          });
        }

        const response = await fetch(form.action, {
          method: "POST",
          headers: { "Content-Type": "application/json", Accept: "application/json" },
          body: JSON.stringify({
            buyerName: buyerName,
            buyerEmail: buyerEmail,
            buyerPhone: buyerPhone,
            buyerAddress: buyerAddress,
            buyerWallet: state.account,
            chainOrders: chainOrders,
          }),
        });
        const payload = await response.json().catch(function () { return {}; });
        if (!response.ok) {
          throw new Error(payload.message || "Checkout failed.");
        }
        window.location.href = payload.redirect || "/buyer";
      }

      async function handleEscrowAction(form) {
        const action = form.dataset.escrowAction;
        const escrowOrderId = form.dataset.escrowOrderId;
        const expectedWallet = (form.dataset.expectedWallet || "").toLowerCase();
        if (!escrowOrderId) {
          throw new Error("Escrow order ID missing.");
        }
        if (action === "ship" && !expectedWallet) {
          throw new Error("Seller wallet missing for this order. Ask the seller to reconnect.");
        }
        if (expectedWallet) {
          await ensureExpectedAccount(expectedWallet);
        }
        if (action === "ship") {
          const verification = await fetchVerificationStatus(state.account);
          if (!verification.seller) {
            throw new Error("Seller not verified. Verify with MetaMask first.");
          }
        }
        if (action === "ship") {
          try {
            const chainOrder = await state.contract.getOrder(escrowOrderId);
            if (!chainOrder.shipped) {
              await (await state.contract.confirmShipment(escrowOrderId)).wait();
            }
          } catch (err) {
            const reason = normalizeRpcError(err);
            throw new Error(reason || "Shipment confirmation failed.");
          }
        } else if (action === "deliver") {
          try {
            await (await state.contract.confirmDelivery(escrowOrderId)).wait();
            await (await state.contract.releasePayment(escrowOrderId)).wait();
          } catch (err) {
            const reason = normalizeRpcError(err);
            throw new Error(reason || "Delivery confirmation failed.");
          }
        } else if (action === "rate") {
          const stars = Number(form.querySelector("[name=stars]").value || 5);
          const comment = form.querySelector("[name=comment]").value || "";
          try {
            await (await state.contract.submitRating(escrowOrderId, stars, comment)).wait();
          } catch (err) {
            const reason = normalizeRpcError(err);
            throw new Error(reason || "Rating submission failed.");
          }
        }

        const payload =
          action === "rate"
            ? {
                stars: form.querySelector("[name=stars]").value,
                comment: form.querySelector("[name=comment]").value,
              }
            : {};

        const response = await fetch(form.action, {
          method: "POST",
          headers: { "Content-Type": "application/json", Accept: "application/json" },
          body: JSON.stringify(payload),
        });
        if (!response.ok) {
          const errorPayload = await response.json().catch(function () { return {}; });
          throw new Error(errorPayload.message || "Server update failed.");
        }
        window.location.reload();
      }

      function bindCheckout() {
        const form = document.querySelector("[data-escrow-checkout]");
        if (!form) return;
        form.addEventListener("submit", function (event) {
          event.preventDefault();
          const submitBtn = form.querySelector("button[type=submit]");
          const originalText = submitBtn ? submitBtn.textContent : "";
          if (submitBtn) {
            submitBtn.disabled = true;
            submitBtn.textContent = "Processing...";
          }
          ensureReady()
            .then(function () { return handleCheckout(form); })
            .catch(function (err) { alert(err.message || "Checkout failed."); })
            .finally(function () {
              if (submitBtn) {
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;
              }
            });
        });
      }

      function bindSellerVerification() {
        if (!sellerVerifyForm) return;
        sellerVerifyForm.addEventListener("submit", function (event) {
          event.preventDefault();
          const submitBtn = sellerVerifyForm.querySelector("button[type=submit]");
          const originalText = submitBtn ? submitBtn.textContent : "";
          if (submitBtn) {
            submitBtn.disabled = true;
            submitBtn.textContent = "Verifying...";
          }
          ensureSellerVerification(sellerVerifyForm)
            .then(function () {
              if (sellerVerificationStatus) {
                sellerVerificationStatus.textContent = "Seller verified for " + state.account;
              }
            })
            .catch(function (err) { alert(err.message || "Seller verification failed."); })
            .finally(function () {
              if (submitBtn) {
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;
              }
            });
        });
      }

      function bindEscrowActions() {
        const forms = document.querySelectorAll("form[data-escrow-action]");
        forms.forEach(function (form) {
          form.addEventListener("submit", function (event) {
            event.preventDefault();
            const submitBtn = form.querySelector("button[type=submit]");
            const originalText = submitBtn ? submitBtn.textContent : "";
            if (submitBtn) {
              submitBtn.disabled = true;
              submitBtn.textContent = "Processing...";
            }
            ensureReady()
              .then(function () { return handleEscrowAction(form); })
              .catch(function (err) { alert(err.message || "Transaction failed."); })
              .finally(function () {
                if (submitBtn) {
                  submitBtn.disabled = false;
                  submitBtn.textContent = originalText;
                }
              });
          });
        });
      }

      if (walletBtn) {
        walletBtn.addEventListener("click", function () {
          connectWallet().catch(function (err) {
            alert(err.message || "Unable to connect wallet.");
          });
        });
      }

      if (disconnectBtn) {
        disconnectBtn.addEventListener("click", function () {
          state.account = null;
          state.verification = { seller: false, buyer: false };
          setWalletUI("");
          setSellerLockUI(false);
          setBuyerVerificationHint(false);
        });
      }

      bindCheckout();
      bindSellerVerification();
      bindEscrowActions();
      setSellerLockUI(false);
      setBuyerVerificationHint(false);
      restoreWalletSession().catch(function () {});

      const provider = getProvider();
      if (provider && typeof provider.request === "function") {
        provider.on("accountsChanged", function (accounts) {
          const account = accounts && accounts.length ? accounts[0] : "";
          state.account = account || null;
          setWalletUI(account);
          state.verification = { seller: false, buyer: false };
          fetchVerificationStatus(account).catch(function () {});
        });
      }
    })();
  </script>
</body>
</html>
