  </div>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <% if (typeof script === "string" && script.length) { %>
    <script src="<%= script %>"></script>
  <% } %>
  <script>
    (function () {
      const walletBtn = document.getElementById("connectWalletBtn");
      const walletLabel = document.getElementById("walletAddress");
      const walletRole = document.getElementById("walletRole");
      const walletChain = document.getElementById("walletChain");
      const disconnectBtn = document.getElementById("disconnectWalletBtn");
      const sellerVerifyForm = document.getElementById("sellerVerifyForm");
      const sellerVerificationStatus = document.getElementById("sellerVerificationStatus");
      const sellerVerifiedBadge = document.getElementById("sellerVerifiedBadge");
      const sellerVerificationForm = document.getElementById("sellerVerificationForm");
      const sellerVerifiedSummary = document.getElementById("sellerVerifiedSummary");
      const sellerVerifiedSummaryText = document.getElementById("sellerVerifiedSummaryText");
      const sellerLockedNotice = document.getElementById("sellerLockedNotice");
      const sellerLockTargets = document.querySelectorAll("[data-requires-seller-verified]");
      const sellerWalletField = document.getElementById("sellerWalletField");
      const checkoutForm = document.getElementById("checkoutForm");
      const buyerVerificationHint = document.getElementById("buyerVerificationHint");
      const sellerPageRoot = document.getElementById("sellerVerificationCard");
      const buyerActionForm = document.querySelector(
        'form[data-escrow-action="deliver"], form[data-escrow-action="rate"]'
      );
      const state = {
        provider: null,
        signer: null,
        account: null,
        chainId: null,
        escrowContract: null,
        listingContract: null,
        orderRegistry: null,
        deliveryTracking: null,
        sellerReputation: null,
        notarizationContract: null,
        verification: { seller: false, buyer: false },
      };
      const STORAGE_KEYS = {
        seller: "popmartSellerWallet",
        buyer: "popmartBuyerWallet",
      };
      const txLocks = {};

      function withTxLock(key, fn) {
        if (txLocks[key]) {
          return Promise.reject(new Error("Transaction already pending."));
        }
        txLocks[key] = true;
        return Promise.resolve()
          .then(fn)
          .finally(function () {
            txLocks[key] = false;
          });
      }

      function isSellerPage() {
        return Boolean(sellerPageRoot);
      }

      function isBuyerPage() {
        return Boolean(buyerActionForm);
      }

      function loadPreferredWallet(role) {
        if (!window.localStorage) return "";
        return String(window.localStorage.getItem(STORAGE_KEYS[role]) || "");
      }

      function rememberWallet(role, address) {
        if (!window.localStorage || !address) return;
        window.localStorage.setItem(STORAGE_KEYS[role], address);
      }

      function getRoleLabel(address) {
        if (!address) return "";
        const account = address.toLowerCase();
        const sellerForms = Array.from(
          document.querySelectorAll('form[data-escrow-action="ship"]')
        );
        const buyerForms = Array.from(
          document.querySelectorAll(
            'form[data-escrow-action="deliver"], form[data-escrow-action="rate"]'
          )
        );
        const sellerWallets = new Set(
          sellerForms
            .map(function (form) {
              return (form.dataset.expectedWallet || "").toLowerCase();
            })
            .filter(Boolean)
        );
        const buyerWallets = new Set(
          buyerForms
            .map(function (form) {
              return (form.dataset.expectedWallet || "").toLowerCase();
            })
            .filter(Boolean)
        );
        const isSeller = sellerWallets.has(account) || isSellerPage();
        const isBuyer = buyerWallets.has(account) || isBuyerPage() || Boolean(checkoutForm);
        if (isSeller && isBuyer) return "Buyer/Seller";
        if (isSeller) return "Seller";
        if (isBuyer) return "Buyer";
        return "";
      }

      function setWalletUI(address) {
        const role = address ? getRoleLabel(address) : "";
        if (walletLabel) {
          if (!address) {
            walletLabel.textContent = "";
          } else if (role) {
            walletLabel.textContent = role + ": " + address;
          } else {
            walletLabel.textContent = address;
          }
        }
        if (walletBtn) {
          walletBtn.textContent = address ? "Wallet connected" : "Connect wallet";
        }
        if (sellerWalletField) {
          sellerWalletField.value = address || "";
        }
        if (walletRole) {
          if (address && role) {
            walletRole.style.display = "inline-flex";
            walletRole.textContent = role;
          } else {
            walletRole.style.display = "none";
            walletRole.textContent = "";
          }
        }
        if (walletChain) {
          walletChain.style.display = "none";
          walletChain.textContent = "";
        }
      }

      function setSellerLockUI(verified) {
        sellerLockTargets.forEach(function (el) {
          el.style.display = verified ? "" : "none";
        });
        if (sellerLockedNotice) {
          sellerLockedNotice.style.display = verified ? "none" : "block";
        }
        if (sellerVerifiedBadge) {
          sellerVerifiedBadge.style.display = verified ? "inline-flex" : "none";
        }
        if (sellerVerificationForm) {
          sellerVerificationForm.style.display = verified ? "none" : "block";
        }
        if (sellerVerifiedSummary) {
          sellerVerifiedSummary.style.display = verified ? "flex" : "none";
        }
      }

      function setBuyerVerificationHint(verified) {
        if (!buyerVerificationHint) return;
        buyerVerificationHint.textContent = verified
          ? "Buyer details captured for checkout."
          : "Add phone + email before checkout.";
      }

      function getProvider() {
        if (!window.ethereum) return null;
        if (Array.isArray(window.ethereum.providers)) {
          return window.ethereum.providers.find((p) => p.isMetaMask) || window.ethereum.providers[0];
        }
        return window.ethereum;
      }

      async function loadArtifact(path) {
        const res = await fetch(path, { cache: "no-store" });
        if (!res.ok) {
          throw new Error("Missing contract artifact: " + path);
        }
        return res.json();
      }

      async function resolveAddress(artifact, provider) {
        const networks = artifact.networks || {};
        const network = await provider.getNetwork();
        const chainId = String(network.chainId);
        const networkId = await provider.send("net_version", []).catch(function () {
          return null;
        });
        const direct = networks[chainId];
        if (direct && direct.address) {
          return { address: direct.address, chainId, networkId, usedNetworkKey: chainId };
        }
        if (networkId && networks[networkId] && networks[networkId].address) {
          return {
            address: networks[networkId].address,
            chainId,
            networkId,
            usedNetworkKey: String(networkId),
          };
        }
        const keys = Object.keys(networks);
        if (keys.length === 1 && networks[keys[0]].address) {
          return {
            address: networks[keys[0]].address,
            chainId,
            networkId,
            usedNetworkKey: String(keys[0]),
          };
        }
        return { address: null, chainId, networkId, usedNetworkKey: null };
      }

      async function findDeployedAddress(artifact, provider) {
        const networks = artifact.networks || {};
        const entries = Object.entries(networks);
        for (const entry of entries) {
          const key = entry[0];
          const info = entry[1];
          if (!info || !info.address) continue;
          const code = await provider.getCode(info.address);
          if (code && code !== "0x") {
            return { address: info.address, usedNetworkKey: String(key) };
          }
        }
        return null;
      }

      async function initContracts() {
        if (!window.ethers) {
          throw new Error("Ethers library not loaded.");
        }
        const provider = getProvider();
        if (!provider) {
          throw new Error("MetaMask not detected.");
        }
        if (!state.provider) {
          state.provider = new window.ethers.providers.Web3Provider(provider);
          state.signer = state.provider.getSigner();
        }
        const escrowArtifact = await loadArtifact("/build/PaymentEscrow.json");
        const escrowDeployment = await resolveAddress(escrowArtifact, state.provider);
        if (!escrowDeployment.address) {
          const suffix = escrowDeployment.networkId ? ` (network id ${escrowDeployment.networkId})` : "";
          throw new Error(`Escrow contract not deployed for chain ${escrowDeployment.chainId}${suffix}.`);
        }
        const escrowCode = await state.provider.getCode(escrowDeployment.address);
        if (!escrowCode || escrowCode === "0x") {
          const discovered = await findDeployedAddress(escrowArtifact, state.provider);
          if (discovered) {
            escrowDeployment.address = discovered.address;
            escrowDeployment.usedNetworkKey = discovered.usedNetworkKey;
          } else {
            const suffix = escrowDeployment.networkId ? `, network id ${escrowDeployment.networkId}` : "";
            const usedKey = escrowDeployment.usedNetworkKey
              ? ` from artifact network ${escrowDeployment.usedNetworkKey}`
              : "";
            throw new Error(
              `Escrow contract not found at ${escrowDeployment.address}. You are on chain ${escrowDeployment.chainId}${suffix}${usedKey}. Check MetaMask RPC (Ganache 127.0.0.1:7545) or re-deploy.`
            );
          }
        }
        state.escrowContract = new window.ethers.Contract(
          escrowDeployment.address,
          escrowArtifact.abi,
          state.signer
        );

        const [listingAddress, orderRegistryAddress, deliveryAddress] = await Promise.all([
          state.escrowContract.listingContract(),
          state.escrowContract.orderRegistry(),
          state.escrowContract.deliveryTracking(),
        ]);

        const listingArtifact = await loadArtifact("/build/MarketplaceListing.json");
        state.listingContract = new window.ethers.Contract(
          listingAddress,
          listingArtifact.abi,
          state.signer
        );

        const registryArtifact = await loadArtifact("/build/OrderRegistry.json");
        state.orderRegistry = new window.ethers.Contract(
          orderRegistryAddress,
          registryArtifact.abi,
          state.signer
        );

        const deliveryArtifact = await loadArtifact("/build/DeliveryTracking.json");
        state.deliveryTracking = new window.ethers.Contract(
          deliveryAddress,
          deliveryArtifact.abi,
          state.signer
        );

        const reputationArtifact = await loadArtifact("/build/SellerReputation.json");
        const reputationDeployment = await resolveAddress(reputationArtifact, state.provider);
        if (reputationDeployment.address) {
          state.sellerReputation = new window.ethers.Contract(
            reputationDeployment.address,
            reputationArtifact.abi,
            state.signer
          );
        }

        const notarizationArtifact = await loadArtifact("/build/Notarization.json");
        const notarizationDeployment = await resolveAddress(notarizationArtifact, state.provider);
        if (notarizationDeployment.address) {
          state.notarizationContract = new window.ethers.Contract(
            notarizationDeployment.address,
            notarizationArtifact.abi,
            state.signer
          );
        }
      }

      async function initNotarizationContract() {
        await initContracts();
        if (!state.notarizationContract) {
          throw new Error("Notarization contract not deployed on this network.");
        }
      }

      async function connectWallet() {
        const provider = getProvider();
        if (!provider) {
          throw new Error("MetaMask not detected.");
        }
        try {
          if (provider.request) {
            await provider.request({
              method: "wallet_requestPermissions",
              params: [{ eth_accounts: {} }],
            });
          }
        } catch (err) {
          if (err && err.code === -32002) {
            throw new Error("MetaMask request already pending. Open MetaMask to continue.");
          }
          if (err && err.code !== 4001) {
            // Ignore non-critical permission errors and fall back to requesting accounts.
          }
        }
        try {
          await provider.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: "0x539" }],
          });
        } catch (err) {
          if (err && err.code === 4902) {
            await provider.request({
              method: "wallet_addEthereumChain",
              params: [
                {
                  chainId: "0x539",
                  chainName: "Ganache 1337",
                  rpcUrls: ["http://127.0.0.1:7545"],
                  nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
                },
              ],
            });
          } else if (err && err.code !== 4001) {
            throw err;
          }
        }
        const accounts = await provider.request({ method: "eth_requestAccounts" });
        state.account = accounts && accounts.length ? accounts[0] : null;
        if (state.provider) {
          const network = await state.provider.getNetwork().catch(function () { return null; });
          state.chainId = network ? Number(network.chainId) : null;
        }
        setWalletUI(state.account);
        if (state.account) {
          if (isSellerPage()) {
            rememberWallet("seller", state.account);
          } else if (isBuyerPage() || checkoutForm) {
            rememberWallet("buyer", state.account);
          }
        }
        if (!state.escrowContract) {
          await initContracts();
        }
        await fetchVerificationStatus(state.account);
        await syncSellerWallet(state.account);
        return state.account;
      }

      async function requestAccountSelection() {
        const provider = getProvider();
        if (!provider) {
          throw new Error("MetaMask not detected.");
        }
        try {
          if (provider.request) {
            await provider.request({
              method: "wallet_requestPermissions",
              params: [{ eth_accounts: {} }],
            });
          }
        } catch (err) {
          if (err && err.code === -32002) {
            throw new Error("MetaMask request already pending. Open MetaMask to continue.");
          }
          if (err && err.code !== 4001) {
            // Ignore non-critical permission errors and fall back to requesting accounts.
          }
        }
        const accounts = await provider.request({ method: "eth_requestAccounts" });
        state.account = accounts && accounts.length ? accounts[0] : null;
        if (state.provider) {
          const network = await state.provider.getNetwork().catch(function () { return null; });
          state.chainId = network ? Number(network.chainId) : null;
        }
        setWalletUI(state.account);
        if (state.account) {
          if (isSellerPage()) {
            rememberWallet("seller", state.account);
          } else if (isBuyerPage() || checkoutForm) {
            rememberWallet("buyer", state.account);
          }
        }
        if (!state.escrowContract) {
          await initContracts();
        }
        await fetchVerificationStatus(state.account);
        await syncSellerWallet(state.account);
        return state.account;
      }

      async function restoreWalletSession() {
        const provider = getProvider();
        if (!provider || typeof provider.request !== "function") return;
        const accounts = await provider.request({ method: "eth_accounts" });
        const account = accounts && accounts.length ? accounts[0] : "";
        state.account = account || null;
        if (state.provider) {
          const network = await state.provider.getNetwork().catch(function () { return null; });
          state.chainId = network ? Number(network.chainId) : null;
        }
        setWalletUI(account);
        if (account) {
          if (!state.escrowContract) {
            await initContracts();
          }
          await fetchVerificationStatus(account);
          await syncSellerWallet(account);
        } else {
          state.verification = { seller: false, buyer: false };
          setSellerLockUI(false);
          setBuyerVerificationHint(false);
        }
      }

      async function ensureReady() {
        if (!state.account) {
          await connectWallet();
        }
        if (!state.escrowContract) {
          await initContracts();
        }
      }

      async function ensureNotarizationReady() {
        if (!state.account) {
          await connectWallet();
        }
        if (!state.notarizationContract) {
          await initNotarizationContract();
        }
      }

      async function ensureExpectedAccount(expectedWallet) {
        if (!expectedWallet) return;
        const provider = getProvider();
        if (!provider) {
          throw new Error("MetaMask not detected.");
        }
        if (!state.account) {
          await connectWallet();
        }
        if (state.account && state.account.toLowerCase() !== expectedWallet) {
          const accounts = await provider.request({ method: "eth_requestAccounts" });
          state.account = accounts && accounts.length ? accounts[0] : null;
          setWalletUI(state.account);
        }
        if (!state.account || state.account.toLowerCase() !== expectedWallet) {
          throw new Error(
            "Switch MetaMask to " + expectedWallet + " before continuing."
          );
        }
        await syncSellerWallet(state.account);
      }

      async function fetchVerificationStatus(address) {
        if (!address) {
          state.verification = { seller: false, buyer: false };
          setSellerLockUI(false);
          setBuyerVerificationHint(false);
          return state.verification;
        }
        const sellerVerified = Boolean(address);
        const buyerVerified = Boolean(address);
        state.verification = { seller: sellerVerified, buyer: buyerVerified };
        setSellerLockUI(sellerVerified);
        setBuyerVerificationHint(buyerVerified);
        if (sellerVerificationStatus) {
          sellerVerificationStatus.textContent = sellerVerified
            ? "Wallet connected for " + address
            : "Connect a wallet to continue.";
        }
        if (sellerVerifiedSummaryText) {
          sellerVerifiedSummaryText.textContent = sellerVerified
            ? "Wallet connected for " + address
            : "";
        }
        return state.verification;
      }

      async function syncSellerWallet(address) {
        if (!address) return;
        if (isSellerPage()) {
          rememberWallet("seller", address);
        }
        await fetch("/seller/wallet", {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: "sellerWallet=" + encodeURIComponent(address),
        });
      }

      function normalizeRpcError(err) {
        if (!err) return "";
        const message =
          (err.data && err.data.message) ||
          (err.error && err.error.message) ||
          err.reason ||
          err.message ||
          "";
        return message.replace("execution reverted: ", "").trim();
      }

      function normalizeWalletError(err) {
        if (!err) return "Transaction failed.";
        if (err.code === 4001 || err.code === "ACTION_REJECTED") {
          return "Transaction cancelled in MetaMask.";
        }
        const raw = normalizeRpcError(err);
        if (/user rejected/i.test(raw)) {
          return "Transaction cancelled in MetaMask.";
        }
        return raw || "Transaction failed.";
      }

      async function ensureSellerVerification(form) {
        if (!form) return state.verification;
        const name = form.querySelector("[name=sellerName]").value.trim();
        const email = form.querySelector("[name=sellerEmail]").value.trim();
        const phone = form.querySelector("[name=sellerPhone]").value.trim();
        if (!name || !email || !phone) {
          throw new Error("Provide name, email, and phone.");
        }
        return withTxLock("verify-seller", async function () {
          await requestAccountSelection();
          if (state.verification.seller) return state.verification;
          state.verification = { ...state.verification, seller: true };
          setSellerLockUI(true);
          if (sellerVerificationStatus) {
            sellerVerificationStatus.textContent = "Wallet connected for " + state.account;
          }
          if (sellerVerifiedSummaryText) {
            sellerVerifiedSummaryText.textContent = "Wallet connected for " + state.account;
          }
          return state.verification;
        });
      }

      async function ensureBuyerVerification(info) {
        await ensureReady();
        const current = await fetchVerificationStatus(state.account);
        if (current.buyer) return current;
        const hasInfo = Boolean(info && info.name && info.email && info.phone);
        state.verification = { ...state.verification, buyer: hasInfo };
        setBuyerVerificationHint(hasInfo);
        return state.verification;
      }

      async function handleCheckout(form) {
        const cartEl = document.getElementById("cartData");
        const cart = cartEl ? JSON.parse(cartEl.textContent || "[]") : [];
        if (!cart.length) {
          throw new Error("Your cart is empty.");
        }
        if (state.account) {
          const account = state.account.toLowerCase();
          const ownItem = cart.find(function (item) {
            return (
              item.sellerWallet &&
              String(item.sellerWallet).toLowerCase() === account
            );
          });
          if (ownItem) {
            throw new Error("Sellers cannot buy their own products.");
          }
        }
        const buyerName = form.querySelector("[name=buyerName]").value;
        const buyerEmail = form.querySelector("[name=buyerEmail]").value;
        const buyerPhone = form.querySelector("[name=buyerPhone]").value;
        const buyerAddress = form.querySelector("[name=buyerAddress]").value;
        const chainOrders = [];
        const orderReceipts = [];
        await ensureBuyerVerification({
          name: buyerName,
          email: buyerEmail,
          phone: buyerPhone,
        });
        const network = await state.provider.getNetwork();
        const chainId = network.chainId;

        await withTxLock("checkout", async function () {
          for (const item of cart) {
            if (!item.sellerWallet || !window.ethers.utils.isAddress(item.sellerWallet)) {
              throw new Error(
                "Missing or invalid seller wallet for " + item.name + ". Ask the seller to reconnect."
              );
            }
            const qty = Number(item.qty || 0);
            const listingId = Number(item.productId || 0);
            const itemPriceWei = window.ethers.utils.parseEther(String(item.priceEth || 0));
            const priceWei = await state.listingContract.getPrice(listingId);
            let expectedOrderId = null;
            let tx = null;
            if (priceWei && !priceWei.eq(0) && priceWei.eq(itemPriceWei)) {
              const totalWei = priceWei.mul(window.ethers.BigNumber.from(qty));
              expectedOrderId = await state.escrowContract.callStatic.pay(
                listingId,
                qty,
                { value: totalWei }
              );
              tx = await state.escrowContract.pay(listingId, qty, { value: totalWei });
            } else {
              expectedOrderId = await state.orderRegistry.callStatic.createOrder(
                listingId,
                state.account,
                item.sellerWallet,
                qty
              );
              tx = await state.orderRegistry.createOrder(
                listingId,
                state.account,
                item.sellerWallet,
                qty
              );
            }
            const receipt = await tx.wait();
            const orderHash = window.ethers.utils.solidityKeccak256(
              ["address", "address", "uint256", "uint256", "uint256", "uint256", "uint256"],
              [state.account, item.sellerWallet, listingId, qty, itemPriceWei, expectedOrderId, chainId]
            );
            chainOrders.push({
              orderId: String(expectedOrderId),
              txHash: receipt.transactionHash,
            });
            orderReceipts.push({
              orderHash: orderHash,
              escrowOrderId: String(expectedOrderId),
              notarizeTxHash: "",
            });
          }
        });

        const response = await fetch(form.action, {
          method: "POST",
          headers: { "Content-Type": "application/json", Accept: "application/json" },
          body: JSON.stringify({
            buyerName: buyerName,
            buyerEmail: buyerEmail,
            buyerPhone: buyerPhone,
            buyerAddress: buyerAddress,
            buyerWallet: state.account,
            chainOrders: chainOrders,
            orderReceipts: orderReceipts,
          }),
        });
        const payload = await response.json().catch(function () { return {}; });
        if (!response.ok) {
          throw new Error(payload.message || "Checkout failed.");
        }
        if (state.account) {
          rememberWallet("buyer", state.account);
        }
        window.location.href = payload.redirect || "/buyer";
      }

      async function handleEscrowAction(form) {
        const action = form.dataset.escrowAction;
        const escrowOrderId = form.dataset.escrowOrderId;
        const expectedWallet = (form.dataset.expectedWallet || "").toLowerCase();
        if (!escrowOrderId) {
          throw new Error("Escrow order ID missing.");
        }
        if (action === "ship" && !expectedWallet) {
          throw new Error("Seller wallet missing for this order. Ask the seller to reconnect.");
        }
        if (expectedWallet) {
          await ensureExpectedAccount(expectedWallet);
        }
        if (action === "ship") {
          const verification = await fetchVerificationStatus(state.account);
          if (!verification.seller) {
            throw new Error("Seller not verified. Verify with MetaMask first.");
          }
        }
        const lockKey = "escrow-" + action + "-" + escrowOrderId;
        await withTxLock(lockKey, async function () {
          if (action === "ship") {
            try {
              const delivery = await state.deliveryTracking.deliveries(escrowOrderId);
              let status = Number(delivery && delivery.status != null ? delivery.status : 0);
              if (status < 1) {
                await (await state.deliveryTracking.markShipped(escrowOrderId, "")).wait();
                status = 1;
              }
              if (status < 2) {
                await (await state.deliveryTracking.markInTransit(escrowOrderId)).wait();
                status = 2;
              }
              if (status < 3) {
                await (await state.deliveryTracking.markDelivered(escrowOrderId)).wait();
                status = 3;
              }
            } catch (err) {
              const reason = normalizeRpcError(err);
              throw new Error(reason || "Shipment update failed.");
            }
          } else if (action === "deliver") {
            try {
              const delivery = await state.deliveryTracking.deliveries(escrowOrderId);
              const status = Number(delivery && delivery.status != null ? delivery.status : 0);
              if (status < 3) {
                throw new Error("Seller must mark delivery before buyer confirmation.");
              }
              await (await state.deliveryTracking.confirmDelivery(escrowOrderId)).wait();
              if (state.escrowContract) {
                await (await state.escrowContract.release(escrowOrderId)).wait();
              }
            } catch (err) {
              const reason = normalizeRpcError(err);
              throw new Error(reason || "Delivery confirmation failed.");
            }
          } else if (action === "rate") {
            const stars = Number(form.querySelector("[name=stars]").value || 5);
            const comment = form.querySelector("[name=comment]").value || "";
            try {
              if (!state.sellerReputation) {
                throw new Error("Seller reputation contract not deployed.");
              }
              await (await state.sellerReputation.rateOrder(escrowOrderId, stars)).wait();
            } catch (err) {
              const reason = normalizeRpcError(err);
              throw new Error(reason || "Rating submission failed.");
            }
          }
        });

        const payload =
          action === "rate"
            ? {
                stars: form.querySelector("[name=stars]").value,
                comment: form.querySelector("[name=comment]").value,
              }
            : {};

        const response = await fetch(form.action, {
          method: "POST",
          headers: { "Content-Type": "application/json", Accept: "application/json" },
          body: JSON.stringify(payload),
        });
        if (!response.ok) {
          const errorPayload = await response.json().catch(function () { return {}; });
          throw new Error(errorPayload.message || "Server update failed.");
        }
        window.location.reload();
      }

      function bindCheckout() {
        const form = document.querySelector("[data-escrow-checkout]");
        if (!form) return;
        form.addEventListener("submit", function (event) {
          event.preventDefault();
          if (state.account) {
            const cartEl = document.getElementById("cartData");
            const cart = cartEl ? JSON.parse(cartEl.textContent || "[]") : [];
            const account = state.account.toLowerCase();
            const ownItem = cart.find(function (item) {
              return (
                item.sellerWallet &&
                String(item.sellerWallet).toLowerCase() === account
              );
            });
            if (ownItem) {
              alert("Sellers cannot buy their own products.");
              return;
            }
          }
          const submitBtn = form.querySelector("button[type=submit]");
          const originalText = submitBtn ? submitBtn.textContent : "";
          if (submitBtn) {
            submitBtn.disabled = true;
            submitBtn.textContent = "Processing...";
          }
          ensureReady()
            .then(function () { return handleCheckout(form); })
            .catch(function (err) { alert(normalizeWalletError(err)); })
            .finally(function () {
              if (submitBtn) {
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;
              }
            });
        });
      }

      function bindSellerVerification() {
        if (!sellerVerifyForm) return;
        const selectSellerBtn = document.getElementById("selectSellerWalletBtn");
        if (selectSellerBtn) {
          selectSellerBtn.addEventListener("click", function () {
            requestAccountSelection().catch(function (err) {
              alert(err.message || "Unable to select seller wallet.");
            });
          });
        }
        sellerVerifyForm.addEventListener("submit", function (event) {
          event.preventDefault();
          const submitBtn = sellerVerifyForm.querySelector("button[type=submit]");
          const originalText = submitBtn ? submitBtn.textContent : "";
          if (submitBtn) {
            submitBtn.disabled = true;
            submitBtn.textContent = "Verifying...";
          }
          ensureSellerVerification(sellerVerifyForm)
            .then(function () {
              if (sellerVerificationStatus) {
                sellerVerificationStatus.textContent = "Seller verified for " + state.account;
              }
            })
            .catch(function (err) { alert(normalizeWalletError(err)); })
            .finally(function () {
              if (submitBtn) {
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;
              }
            });
        });
      }

      function bindEscrowActions() {
        const forms = document.querySelectorAll("form[data-escrow-action]");
        forms.forEach(function (form) {
          form.addEventListener("submit", function (event) {
            event.preventDefault();
            const submitBtn = form.querySelector("button[type=submit]");
            const originalText = submitBtn ? submitBtn.textContent : "";
            if (submitBtn) {
              submitBtn.disabled = true;
              submitBtn.textContent = "Processing...";
            }
            ensureReady()
              .then(function () { return handleEscrowAction(form); })
              .catch(function (err) { alert(normalizeWalletError(err)); })
              .finally(function () {
                if (submitBtn) {
                  submitBtn.disabled = false;
                  submitBtn.textContent = originalText;
                }
            });
          });
        });
      }

      function getReceiptPayload(btn) {
        return {
          orderId: Number(btn.dataset.orderId || 0),
          type: String(btn.dataset.receiptType || "delivery"),
          seller: String(btn.dataset.sellerWallet || ""),
          buyer: String(btn.dataset.buyerWallet || ""),
          productName: String(btn.dataset.productName || ""),
          qty: Number(btn.dataset.qty || 0),
          priceEth: String(btn.dataset.priceEth || "0"),
          deliveredAt: String(btn.dataset.deliveredAt || ""),
          shippedAt: String(btn.dataset.shippedAt || ""),
        };
      }

      function buildReceiptHash(payload) {
        const priceWei = window.ethers.utils.parseEther(String(payload.priceEth || "0"));
        return window.ethers.utils.solidityKeccak256(
          ["uint256", "address", "address", "string", "uint256", "uint256", "string"],
          [
            payload.orderId,
            payload.seller || window.ethers.constants.AddressZero,
            payload.buyer || window.ethers.constants.AddressZero,
            payload.productName,
            payload.qty,
            priceWei,
            payload.type,
          ]
        );
      }

      function formatTimestampFromSeconds(seconds) {
        const ts = Number(seconds || 0);
        if (!ts) return "";
        const date = new Date(ts * 1000);
        return date.toLocaleString();
      }

      function bindReceiptVerification() {
        const buttons = document.querySelectorAll("[data-receipt-verify]");
        buttons.forEach(function (btn) {
          btn.addEventListener("click", function () {
            const payload = getReceiptPayload(btn);
            const card = btn.closest("div");
            const statusEl = card ? card.querySelector("[data-verify-status]") : null;
            const timeEl = card ? card.querySelector("[data-verify-timestamp]") : null;
            const proofForm = btn.closest("div") && btn.closest("div").parentElement
              ? btn.closest("div").parentElement.querySelector("form[data-proof-upload]")
              : null;
            if (!payload.orderId) return;
            if (!window.ethereum) {
              if (statusEl) statusEl.textContent = "MetaMask not detected.";
              return;
            }
            if (statusEl) statusEl.textContent = "Verifying...";
            if (timeEl) timeEl.textContent = "";
            withTxLock("receipt-verify-" + payload.type + "-" + payload.orderId, function () {
              return connectWallet()
                .then(function () { return ensureNotarizationReady(); })
                .then(function () {
                  if (payload.type === "purchase") {
                    return state.notarizationContract.verifyPurchase(payload.orderId);
                  }
                  if (payload.type === "shipment") {
                    return state.notarizationContract.verifyShipment(payload.orderId);
                  }
                  return state.notarizationContract.verifyDelivery(payload.orderId);
                })
                .then(function (result) {
                  const timestamp = result && result.timestamp ? result.timestamp : result[1];
                  if (timestamp && Number(timestamp) > 0) {
                    if (statusEl) statusEl.textContent = "Verified on-chain.";
                    if (timeEl) timeEl.textContent = "Notarized: " + formatTimestampFromSeconds(timestamp);
                    if (proofForm) {
                      const submitBtn = proofForm.querySelector("button[type=submit]");
                      if (submitBtn) submitBtn.disabled = false;
                    }
                    return null;
                  }
                  const canNotarize = String(btn.dataset.canNotarize || "") === "true";
                  if (!canNotarize) {
                    if (statusEl) statusEl.textContent = "Not notarized yet.";
                    return null;
                  }
                  const receiptHash = buildReceiptHash(payload);
                  if (statusEl) statusEl.textContent = "Notarizing...";
                  if (payload.type === "purchase") {
                    return state.notarizationContract.notarizePurchase(payload.orderId, receiptHash);
                  }
                  if (payload.type === "shipment") {
                    return state.notarizationContract.notarizeShipment(payload.orderId, receiptHash);
                  }
                  return state.notarizationContract.notarizeDelivery(payload.orderId, receiptHash);
                })
                .then(function (tx) {
                  if (!tx) return null;
                  return tx.wait();
                })
                .then(function (result) {
                  if (!result) return;
                  if (payload.type === "purchase") {
                    return state.notarizationContract.verifyPurchase(payload.orderId);
                  }
                  if (payload.type === "shipment") {
                    return state.notarizationContract.verifyShipment(payload.orderId);
                  }
                  return state.notarizationContract.verifyDelivery(payload.orderId);
                })
                .then(function (result) {
                  if (!result) return;
                  const timestamp = result && result.timestamp ? result.timestamp : result[1];
                  if (timestamp && Number(timestamp) > 0) {
                    if (statusEl) statusEl.textContent = "Verified on-chain.";
                    if (timeEl) timeEl.textContent = "Notarized: " + formatTimestampFromSeconds(timestamp);
                    if (proofForm) {
                      const submitBtn = proofForm.querySelector("button[type=submit]");
                      if (submitBtn) submitBtn.disabled = false;
                    }
                  }
                })
                .catch(function (err) {
                  if (statusEl) statusEl.textContent = err.message || "Verification failed.";
                });
            }).catch(function (err) {
              if (statusEl) statusEl.textContent = err.message || "Verification failed.";
            });
          });
        });
      }

      function buildReceiptHtml(payload, timestampLabel) {
        const priceEth = payload.priceEth || "0";
        const deliveredAt = payload.deliveredAt || "Pending";
        const shippedAt = payload.shippedAt || "Pending";
        const title = payload.type === "shipment" ? "Shipment Receipt" : "Delivery Receipt";
        return `
          <html>
            <head>
              <title>${title}</title>
              <style>
                body { font-family: "Segoe UI", Arial, sans-serif; padding: 24px; color: #111827; }
                h1 { margin: 0 0 8px; font-size: 22px; }
                .muted { color: #6b7280; font-size: 12px; }
                .card { border: 1px solid #e5e7eb; border-radius: 12px; padding: 16px; margin-top: 12px; }
                .row { display: flex; justify-content: space-between; margin: 6px 0; }
              </style>
            </head>
            <body>
              <h1>${title}</h1>
              <div class="muted">Generated by seller</div>
              <div class="card">
                <div class="row"><strong>Order ID</strong><span>#${payload.orderId}</span></div>
                <div class="row"><strong>Product</strong><span>${payload.productName}</span></div>
                <div class="row"><strong>Qty</strong><span>${payload.qty}</span></div>
                <div class="row"><strong>Price</strong><span>${priceEth} ETH</span></div>
                <div class="row"><strong>Seller</strong><span>${payload.seller}</span></div>
                <div class="row"><strong>Buyer</strong><span>${payload.buyer}</span></div>
                ${
                  payload.type === "shipment"
                    ? `<div class="row"><strong>Shipped</strong><span>${shippedAt}</span></div>`
                    : `<div class="row"><strong>Delivered</strong><span>${deliveredAt}</span></div>`
                }
                <div class="row"><strong>Notarized</strong><span>${timestampLabel || "Pending"}</span></div>
                <div class="muted" style="margin-top:10px;">This receipt is notarized on-chain.</div>
              </div>
            </body>
          </html>
        `;
      }

      function bindReceiptPrint() {
        const buttons = document.querySelectorAll("[data-receipt-print]");
        buttons.forEach(function (btn) {
          btn.addEventListener("click", function () {
            const payload = getReceiptPayload(btn);
            if (!payload.orderId) return;
            if (!window.ethereum) {
              alert("MetaMask not detected.");
              return;
            }
            const card = btn.closest("div");
            const statusEl = card ? card.querySelector("[data-verify-status]") : null;
            const timeEl = card ? card.querySelector("[data-verify-timestamp]") : null;
            if (statusEl) statusEl.textContent = "Preparing receipt...";
            withTxLock("receipt-print-" + payload.type + "-" + payload.orderId, function () {
              return connectWallet()
                .then(function () { return ensureNotarizationReady(); })
                .then(function () {
                  if (payload.type === "shipment") {
                    return state.notarizationContract.verifyShipment(payload.orderId);
                  }
                  return state.notarizationContract.verifyDelivery(payload.orderId);
                })
                .then(function (result) {
                  const timestamp = result && result.timestamp ? result.timestamp : result[1];
                  if (!timestamp || Number(timestamp) === 0) {
                    const receiptHash = buildReceiptHash(payload);
                    const notarizeFn = payload.type === "shipment"
                      ? state.notarizationContract.notarizeShipment
                      : state.notarizationContract.notarizeDelivery;
                    return notarizeFn(payload.orderId, receiptHash)
                      .then(function (tx) { return tx.wait(); })
                      .then(function () {
                        if (payload.type === "shipment") {
                          return state.notarizationContract.verifyShipment(payload.orderId);
                        }
                        return state.notarizationContract.verifyDelivery(payload.orderId);
                      });
                  }
                  return result;
                })
                .then(function (result) {
                  if (!result) return;
                  const timestamp = result && result.timestamp ? result.timestamp : result[1];
                  const tsLabel = formatTimestampFromSeconds(timestamp);
                  if (timeEl) timeEl.textContent = "Notarized: " + tsLabel;
                  if (statusEl) statusEl.textContent = "Receipt ready.";
                  const win = window.open("", "_blank", "width=720,height=900");
                  if (!win) return;
                  win.document.write(buildReceiptHtml(payload, tsLabel));
                  win.document.close();
                  win.focus();
                  win.print();
                })
                .catch(function (err) {
                  if (statusEl) statusEl.textContent = err.message || "Receipt failed.";
                });
            }).catch(function (err) {
              if (statusEl) statusEl.textContent = err.message || "Receipt failed.";
            });
          });
        });
      }

      function bindAddToCartGuard() {
        const forms = document.querySelectorAll('form[action="/cart/add"]');
        forms.forEach(function (form) {
          form.addEventListener("submit", function (event) {
            const sellerWalletInput = form.querySelector('input[name="sellerWallet"]');
            const sellerWallet = sellerWalletInput ? sellerWalletInput.value.toLowerCase() : "";
            const account = state.account ? state.account.toLowerCase() : "";
            if (sellerWallet && account && sellerWallet === account) {
              event.preventDefault();
              alert("Sellers cannot buy their own products.");
            }
          });
        });
      }

      function bindListingCreate() {
        const form = document.querySelector("form[data-listing-create]");
        if (!form) return;
        form.addEventListener("submit", function (event) {
          event.preventDefault();
          const submitBtn = form.querySelector("button[type=submit]");
          const statusEl = form.querySelector("[data-tx-status]");
          const originalText = submitBtn ? submitBtn.textContent : "";
          if (submitBtn) {
            submitBtn.disabled = true;
            submitBtn.textContent = "Publishing...";
          }
          if (statusEl) {
            statusEl.textContent = "Preparing on-chain listing...";
            statusEl.setAttribute("data-status", "pending");
          }
          withTxLock("listing-create", function () {
            return ensureReady()
              .then(function () {
                const walletField = form.querySelector("#sellerWalletField");
                if (walletField) {
                  walletField.value = state.account || "";
                }
                const formData = new FormData(form);
                return fetch("/seller/listings", {
                  method: "POST",
                  headers: { "X-Prepare-Listing": "1" },
                  body: formData,
                });
              })
            .then(function (res) {
              if (!res.ok) {
                throw new Error("Unable to prepare listing.");
              }
              return res.json();
            })
            .then(function (payload) {
              if (!payload || !payload.ok || !payload.listing) {
                throw new Error("Listing data missing.");
              }
              if (!state.listingContract) {
                throw new Error("Listing contract not ready.");
              }
              const listing = payload.listing;
              if (
                state.account &&
                listing.sellerWallet &&
                state.account.toLowerCase() !== listing.sellerWallet.toLowerCase()
              ) {
                throw new Error("Switch MetaMask to the seller wallet before publishing.");
              }
              if (statusEl) {
                statusEl.textContent = "Confirm in MetaMask...";
              }
              const priceWei = window.ethers.utils.parseEther(String(listing.priceEth || 0));
              return state.listingContract
                .createListing(
                  listing.name,
                  listing.category,
                  listing.shortDesc,
                  listing.shortDesc,
                  listing.image,
                  priceWei
                )
                .then(function (tx) { return tx.wait(); })
                .then(function () {
                  return state.listingContract.nextListingId();
                })
                .then(function (nextId) {
                  const listingId = Number(nextId || 0) - 1;
                  return fetch("/seller/listings", {
                    method: "POST",
                    headers: {
                      "Content-Type": "application/json",
                      Accept: "application/json",
                      "X-Commit-Listing": "1",
                    },
                    body: JSON.stringify({
                      listingId: listingId,
                      name: listing.name,
                      category: listing.category,
                      shortDesc: listing.shortDesc,
                      priceEth: listing.priceEth,
                      sellerWallet: listing.sellerWallet,
                      image: listing.image,
                    }),
                  });
                });
            })
            .then(function (res) {
              if (!res || !res.ok) {
                return res && res.json
                  ? res.json().then(function (data) {
                      throw new Error(data.message || "Listing save failed.");
                    })
                  : Promise.reject(new Error("Listing save failed."));
              }
              if (statusEl) {
                statusEl.textContent = "Listing published on-chain.";
                statusEl.setAttribute("data-status", "ok");
              }
              window.location.href = "/";
            })
            .catch(function (err) {
              if (statusEl) {
                statusEl.textContent = normalizeWalletError(err);
                statusEl.setAttribute("data-status", "error");
              }
              if (submitBtn) {
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;
              }
            });
          });
        });
      }

      if (walletBtn) {
        walletBtn.addEventListener("click", function () {
          connectWallet().catch(function (err) {
            alert(err.message || "Unable to connect wallet.");
          });
        });
      }

      if (disconnectBtn) {
        disconnectBtn.addEventListener("click", function () {
          state.account = null;
          state.verification = { seller: false, buyer: false };
          setWalletUI("");
          setSellerLockUI(false);
          setBuyerVerificationHint(false);
        });
      }

      bindCheckout();
      bindSellerVerification();
      bindEscrowActions();
      bindReceiptVerification();
      bindReceiptPrint();
      bindAddToCartGuard();
      bindListingCreate();
      setSellerLockUI(false);
      setBuyerVerificationHint(false);
      restoreWalletSession().catch(function () {});

      async function autoPromptPreferredWallet() {
        const provider = getProvider();
        if (!provider) return;
        const preferred = isSellerPage()
          ? loadPreferredWallet("seller")
          : isBuyerPage()
            ? loadPreferredWallet("buyer")
            : "";
        if (!preferred) return;
        const accounts = await provider.request({ method: "eth_accounts" });
        const current = accounts && accounts.length ? accounts[0] : "";
        if (current && current.toLowerCase() === preferred.toLowerCase()) {
          state.account = current;
          setWalletUI(current);
          return;
        }
        try {
          await requestAccountSelection();
          if (state.account && state.account.toLowerCase() !== preferred.toLowerCase()) {
            await ensureExpectedAccount(preferred.toLowerCase());
          }
        } catch (err) {
          // Ignore auto-prompt errors; user can connect manually.
        }
      }
      const provider = getProvider();
      if (provider && typeof provider.request === "function") {
        provider.on("accountsChanged", function (accounts) {
          const account = accounts && accounts.length ? accounts[0] : "";
          state.account = account || null;
          setWalletUI(account);
          state.verification = { seller: false, buyer: false };
          fetchVerificationStatus(account).catch(function () {});
          if (isSellerPage()) {
            if (account) {
              rememberWallet("seller", account);
              syncSellerWallet(account)
                .catch(function () {})
                .finally(function () {
                  window.location.reload();
                });
            } else {
              window.location.reload();
            }
          }
        });
        provider.on("chainChanged", function () {
          if (!state.provider) return;
          state.provider.getNetwork()
            .then(function (network) {
              state.chainId = network ? Number(network.chainId) : null;
              setWalletUI(state.account);
            })
            .catch(function () {});
        });
      }
    })();
  </script>
</body>
</html>
