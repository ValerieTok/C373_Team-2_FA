  </div>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <% if (typeof script === "string" && script.length) { %>
    <script src="<%= script %>"></script>
  <% } %>
  <script>
    (function () {
      const walletBtn = document.getElementById("connectWalletBtn");
      const walletLabel = document.getElementById("walletAddress");
      const disconnectBtn = document.getElementById("disconnectWalletBtn");
      const state = { provider: null, signer: null, account: null, contract: null };
      const GAS_LIMIT = 600000;

      function getRoleLabel(address) {
        if (!address) return "";
        const account = address.toLowerCase();
        const sellerForms = Array.from(
          document.querySelectorAll('form[data-escrow-action="ship"]')
        );
        const buyerForms = Array.from(
          document.querySelectorAll(
            'form[data-escrow-action="deliver"], form[data-escrow-action="rate"]'
          )
        );
        const sellerWallets = new Set(
          sellerForms
            .map(function (form) {
              return (form.dataset.expectedWallet || "").toLowerCase();
            })
            .filter(Boolean)
        );
        const buyerWallets = new Set(
          buyerForms
            .map(function (form) {
              return (form.dataset.expectedWallet || "").toLowerCase();
            })
            .filter(Boolean)
        );
        const isSeller = sellerWallets.has(account);
        const isBuyer = buyerWallets.has(account);
        if (isSeller && isBuyer) return "Buyer/Seller";
        if (isSeller) return "Seller";
        if (isBuyer) return "Buyer";
        return "";
      }

      function setWalletUI(address) {
        if (walletLabel) {
          const role = address ? getRoleLabel(address) : "";
          if (!address) {
            walletLabel.textContent = "";
          } else if (role) {
            walletLabel.textContent = role + ": " + address;
          } else {
            walletLabel.textContent = address;
          }
        }
        if (walletBtn) {
          walletBtn.textContent = address ? "Wallet connected" : "Connect wallet";
        }
      }

      function getProvider() {
        if (!window.ethereum) return null;
        if (Array.isArray(window.ethereum.providers)) {
          return window.ethereum.providers.find((p) => p.isMetaMask) || window.ethereum.providers[0];
        }
        return window.ethereum;
      }

      async function loadArtifact(path) {
        const res = await fetch(path, { cache: "no-store" });
        if (!res.ok) {
          throw new Error("Missing contract artifact: " + path);
        }
        return res.json();
      }

      async function resolveAddress(artifact, provider) {
        const networks = artifact.networks || {};
        const network = await provider.getNetwork();
        const chainId = String(network.chainId);
        const networkId = await provider.send("net_version", []).catch(function () {
          return null;
        });
        const direct = networks[chainId];
        if (direct && direct.address) {
          return { address: direct.address, chainId, networkId, usedNetworkKey: chainId };
        }
        if (networkId && networks[networkId] && networks[networkId].address) {
          return {
            address: networks[networkId].address,
            chainId,
            networkId,
            usedNetworkKey: String(networkId),
          };
        }
        const keys = Object.keys(networks);
        if (keys.length === 1 && networks[keys[0]].address) {
          return {
            address: networks[keys[0]].address,
            chainId,
            networkId,
            usedNetworkKey: String(keys[0]),
          };
        }
        return { address: null, chainId, networkId, usedNetworkKey: null };
      }

      async function findDeployedAddress(artifact, provider) {
        const networks = artifact.networks || {};
        const entries = Object.entries(networks);
        for (const entry of entries) {
          const key = entry[0];
          const info = entry[1];
          if (!info || !info.address) continue;
          const code = await provider.getCode(info.address);
          if (code && code !== "0x") {
            return { address: info.address, usedNetworkKey: String(key) };
          }
        }
        return null;
      }

      async function initContract() {
        if (!window.ethers) {
          throw new Error("Ethers library not loaded.");
        }
        const provider = getProvider();
        if (!provider) {
          throw new Error("MetaMask not detected.");
        }
        if (!state.provider) {
          state.provider = new window.ethers.providers.Web3Provider(provider);
          state.signer = state.provider.getSigner();
        }
        const artifact = await loadArtifact("/build/EscrowPayment.json");
        const deployment = await resolveAddress(artifact, state.provider);
        if (!deployment.address) {
          const suffix = deployment.networkId ? ` (network id ${deployment.networkId})` : "";
          throw new Error(`Escrow contract not deployed for chain ${deployment.chainId}${suffix}.`);
        }
        const code = await state.provider.getCode(deployment.address);
        if (!code || code === "0x") {
          const discovered = await findDeployedAddress(artifact, state.provider);
          if (discovered) {
            deployment.address = discovered.address;
            deployment.usedNetworkKey = discovered.usedNetworkKey;
          } else {
          const suffix = deployment.networkId ? `, network id ${deployment.networkId}` : "";
          const usedKey = deployment.usedNetworkKey
            ? ` from artifact network ${deployment.usedNetworkKey}`
            : "";
          throw new Error(
            `Escrow contract not found at ${deployment.address}. You are on chain ${deployment.chainId}${suffix}${usedKey}. Check MetaMask RPC (Ganache 127.0.0.1:7545) or re-deploy.`
          );
          }
        }
        state.contract = new window.ethers.Contract(
          deployment.address,
          artifact.abi,
          state.signer
        );
      }

      async function connectWallet() {
        const provider = getProvider();
        if (!provider) {
          throw new Error("MetaMask not detected.");
        }
        try {
          await provider.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: "0x539" }],
          });
        } catch (err) {
          if (err && err.code === 4902) {
            await provider.request({
              method: "wallet_addEthereumChain",
              params: [
                {
                  chainId: "0x539",
                  chainName: "Ganache 1337",
                  rpcUrls: ["http://127.0.0.1:7545"],
                  nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
                },
              ],
            });
          } else if (err && err.code !== 4001) {
            throw err;
          }
        }
        await provider.request({
          method: "wallet_requestPermissions",
          params: [{ eth_accounts: {} }],
        });
        const accounts = await provider.request({ method: "eth_requestAccounts" });
        state.account = accounts && accounts.length ? accounts[0] : null;
        setWalletUI(state.account);
        if (!state.contract) {
          await initContract();
        }
        return state.account;
      }

      async function ensureReady() {
        if (!state.account) {
          await connectWallet();
        }
        if (!state.contract) {
          await initContract();
        }
      }

      async function getNextOrderId() {
        return state.contract.nextOrderId();
      }

      async function handleCheckout(form) {
        const cartEl = document.getElementById("cartData");
        const cart = cartEl ? JSON.parse(cartEl.textContent || "[]") : [];
        if (!cart.length) {
          throw new Error("Your cart is empty.");
        }
        const buyerName = form.querySelector("[name=buyerName]").value;
        const buyerEmail = form.querySelector("[name=buyerEmail]").value;
        const buyerAddress = form.querySelector("[name=buyerAddress]").value;
        const chainOrders = [];

        for (const item of cart) {
          const qty = Number(item.qty || 0);
          const unitPriceWei = window.ethers.utils.parseEther(String(item.priceEth || 0));
          const totalWei = unitPriceWei.mul(window.ethers.BigNumber.from(qty));
          const expectedOrderId = await getNextOrderId();
          const tx = await state.contract.createOrder(
            item.productId,
            qty,
            unitPriceWei,
            { value: totalWei }
          );
          const receipt = await tx.wait();
          chainOrders.push({
            orderId: String(expectedOrderId),
            txHash: receipt.transactionHash,
          });
        }

        const response = await fetch(form.action, {
          method: "POST",
          headers: { "Content-Type": "application/json", Accept: "application/json" },
          body: JSON.stringify({
            buyerName: buyerName,
            buyerEmail: buyerEmail,
            buyerAddress: buyerAddress,
            buyerWallet: state.account,
            chainOrders: chainOrders,
          }),
        });
        const payload = await response.json().catch(function () { return {}; });
        if (!response.ok) {
          throw new Error(payload.message || "Checkout failed.");
        }
        window.location.href = payload.redirect || "/buyer";
      }

      async function handleEscrowAction(form) {
        const action = form.dataset.escrowAction;
        const escrowOrderId = form.dataset.escrowOrderId;
        const expectedWallet = (form.dataset.expectedWallet || "").toLowerCase();
        if (!escrowOrderId) {
          throw new Error("Escrow order ID missing.");
        }
        if (expectedWallet && state.account && state.account.toLowerCase() !== expectedWallet) {
          throw new Error("Switch MetaMask to the expected seller/buyer account before continuing.");
        }
        if (action === "ship") {
          await (await state.contract.confirmShipment(escrowOrderId)).wait();
        } else if (action === "deliver") {
          await (await state.contract.confirmDelivery(escrowOrderId)).wait();
          await (await state.contract.releasePayment(escrowOrderId)).wait();
        } else if (action === "rate") {
          const stars = Number(form.querySelector("[name=stars]").value || 5);
          const comment = form.querySelector("[name=comment]").value || "";
          await (await state.contract.submitRating(escrowOrderId, stars, comment)).wait();
        }

        const payload =
          action === "rate"
            ? {
                stars: form.querySelector("[name=stars]").value,
                comment: form.querySelector("[name=comment]").value,
              }
            : {};

        const response = await fetch(form.action, {
          method: "POST",
          headers: { "Content-Type": "application/json", Accept: "application/json" },
          body: JSON.stringify(payload),
        });
        if (!response.ok) {
          const errorPayload = await response.json().catch(function () { return {}; });
          throw new Error(errorPayload.message || "Server update failed.");
        }
        window.location.reload();
      }

      function bindCheckout() {
        const form = document.querySelector("[data-escrow-checkout]");
        if (!form) return;
        form.addEventListener("submit", function (event) {
          event.preventDefault();
          const submitBtn = form.querySelector("button[type=submit]");
          const originalText = submitBtn ? submitBtn.textContent : "";
          if (submitBtn) {
            submitBtn.disabled = true;
            submitBtn.textContent = "Processing...";
          }
          ensureReady()
            .then(function () { return handleCheckout(form); })
            .catch(function (err) { alert(err.message || "Checkout failed."); })
            .finally(function () {
              if (submitBtn) {
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;
              }
            });
        });
      }

      function bindEscrowActions() {
        const forms = document.querySelectorAll("form[data-escrow-action]");
        forms.forEach(function (form) {
          form.addEventListener("submit", function (event) {
            event.preventDefault();
            const submitBtn = form.querySelector("button[type=submit]");
            const originalText = submitBtn ? submitBtn.textContent : "";
            if (submitBtn) {
              submitBtn.disabled = true;
              submitBtn.textContent = "Processing...";
            }
            ensureReady()
              .then(function () { return handleEscrowAction(form); })
              .catch(function (err) { alert(err.message || "Transaction failed."); })
              .finally(function () {
                if (submitBtn) {
                  submitBtn.disabled = false;
                  submitBtn.textContent = originalText;
                }
              });
          });
        });
      }

      if (walletBtn) {
        walletBtn.addEventListener("click", function () {
          connectWallet().catch(function (err) {
            alert(err.message || "Unable to connect wallet.");
          });
        });
      }

      if (disconnectBtn) {
        disconnectBtn.addEventListener("click", function () {
          state.account = null;
          setWalletUI("");
        });
      }

      bindCheckout();
      bindEscrowActions();

      const provider = getProvider();
      if (provider && typeof provider.request === "function") {
        provider.on("accountsChanged", function (accounts) {
          const account = accounts && accounts.length ? accounts[0] : "";
          state.account = account || null;
          setWalletUI(account);
        });
      }
    })();
  </script>
</body>
</html>
